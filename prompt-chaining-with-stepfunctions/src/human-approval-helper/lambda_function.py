import os
import logging
import json
import boto3

dynamodb = boto3.resource("dynamodb")
states = boto3.client("stepfunctions")
sns = boto3.client("sns")


INPUT_TOXIC_EMAIL = "This is an automatic email generated by product review response system. \n\n A customer has left a review for the product. The system has found the review to have some element of toxicity and the toxicity score is {}. You will find the review below. We like your feedback in finding out if the review is good to be posted.\n\n \
                     **Product review** \n{} \n\n If you find the review comment not toxic, approve the comment by clicking {} \n\n If the comment is toxic, reject the comment by clicking {}"

RESPONSE_TOXIC_EMAIL = "This is an automatic email generated by product review response system. \n\n The system generated an automatic response for the product review posted by the customer. But the reponse is found to have some element of toxicity and the toxicity score is {}. You will find the review and the generated response below. We like your feedback in finding out if the generated response is good to be posted.\n\n \
                     **Generated Response** \n{} \n\n . **Product review** \n{} \n\n . If you find the response not toxic, approve the comment by clicking {} \n\n If the response is toxic, reject the response by clicking {}"
TABLE_NAME = os.getenv("DYNAMO_DB_NAME")


def lambda_handler(event, context):

    """
    This Lambda function has two event source.
    1. If the source is a Step Functions, it expects 'state_payload'. This process
       starts the human-in-the-loop process. This stores the Step Functions token in
       DyanamoDB and sends an email with API Gateway URL links.
    2. If the source is API Gateway, it does the reverse of the previous process. 
       Retrieves the token from DynamoDB and resumes the Step Functions workflow
    """
    if "state_payload" in event:
        do_send_approval_notification(event)

    else:
        return process_approvals(event)


def process_approvals(event):
    """
    Invoke Step Functions workflow to complete the review process.
    Retrieve the Step Functions token corresponding to the runid, 
    pass it to the API to resume the workflow
    """
    params = event["queryStringParameters"]
    message = "Success"
    try:
        token = get_token(params["runid"], params["stage"])
        update_item(params["runid"], params["stage"], params["status"])

        response = states.send_task_success(
            taskToken=token, output=json.dumps(event["queryStringParameters"])
        )
    except Exception as e:
        logging.error("Error at %s", "process_approvals", exc_info=e)
        message = "Failed to complete. Contact admin"

    return {"statusCode": "200", "headers": {"Content-Type":"*/*"}, "body": message}


def do_send_approval_notification(event):
    """send an email requestion to review the toxicity of the content"""
    payload = event["state_payload"]
    runid = event["runid"]
    stage = event["stage"]
    api_url = event["api_url"]
    api_approve_url = f"{api_url}/review?status=APPROVED&stage={stage}&runid={runid}"
    api_reject_url = f"{api_url}/review?status=REJECTED&stage={stage}&runid={runid}"


    if "response_toxicity" in payload:

        message = RESPONSE_TOXIC_EMAIL.format(
            payload["response_toxicity"]["ResultList"][0]["Toxicity"],
            payload["llm"]["review_response"],
            event["review_text"],
            api_approve_url,
            api_reject_url,
        )

        response = sns.publish(
            TopicArn=os.getenv("SNS_TOPIC_ARN"),
            Message=message,
            Subject="Review product review response",
        )
    else:

        message = INPUT_TOXIC_EMAIL.format(
            payload["input_toxicity"]["ResultList"][0]["Toxicity"],
            event["review_text"],
            api_approve_url,
            api_reject_url,
        )

        response = sns.publish(
            TopicArn=os.getenv("SNS_TOPIC_ARN"),
            Message=message,
            Subject="Review product review text",
        )
    put_item(event, runid, stage)


def put_item(event, runid, stage):
    """write the token data"""

    table = dynamodb.Table(TABLE_NAME)

    table.put_item(
        Item={
            "runid": runid,
            "stage": stage,
            "token": event["token"],
            "approval_status": "WAITING_FOR_APPROVAL",
            "payload": float_decimal(event["state_payload"]),
        }
    )


def update_item(runid, stage, status):

    """update the token data"""
    table = dynamodb.Table(TABLE_NAME)

    table.update_item(
        Key={"runid": runid, "stage": stage},
        UpdateExpression="set approval_status = :val1",
        ExpressionAttributeValues={":val1": status},
        ReturnValues="ALL_NEW",
    )


def get_token(runid, stage):
    """Retreives token"""

    table = dynamodb.Table(TABLE_NAME)
    response = table.get_item(Key={"runid": runid, "stage": stage})
    return response["Item"]["token"]


def float_decimal(python_obj: dict) -> dict:
    """converts float object to decimal to update in DynamoDB"""

    from decimal import Decimal

    json.loads(json.dumps(python_obj), parse_float=Decimal)
